var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.push(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.push(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
import { Injectable } from '@angular/core';
import { MINUTE, HOUR, DAY, WEEK, MONTH, YEAR } from './util';
const defaultFormattter = function (then) {
    const now = Date.now();
    const seconds = Math.round(Math.abs(now - then) / 1000);
    const suffix = then < now ? 'ago' : 'from now';
    const [value, unit] = seconds < MINUTE
        ? [Math.round(seconds), 'second']
        : seconds < HOUR
            ? [Math.round(seconds / MINUTE), 'minute']
            : seconds < DAY
                ? [Math.round(seconds / HOUR), 'hour']
                : seconds < WEEK
                    ? [Math.round(seconds / DAY), 'day']
                    : seconds < MONTH
                        ? [Math.round(seconds / WEEK), 'week']
                        : seconds < YEAR
                            ? [Math.round(seconds / MONTH), 'month']
                            : [Math.round(seconds / YEAR), 'year'];
    return { value, unit, suffix };
};
export class TimeagoFormatter {
}
export let TimeagoDefaultFormatter = (() => {
    let _classDecorators = [Injectable()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    var TimeagoDefaultFormatter = class extends TimeagoFormatter {
        static {
            __esDecorate(null, _classDescriptor = { value: this }, _classDecorators, { kind: "class", name: this.name }, null, _classExtraInitializers);
            TimeagoDefaultFormatter = _classThis = _classDescriptor.value;
            __runInitializers(_classThis, _classExtraInitializers);
        }
        format(then) {
            const { suffix, value, unit } = defaultFormattter(then);
            return this.parse(value, unit, suffix);
        }
        parse(value, unit, suffix) {
            if (value !== 1) {
                unit += 's';
            }
            return value + ' ' + unit + ' ' + suffix;
        }
    };
    return TimeagoDefaultFormatter = _classThis;
})();
export let TimeagoCustomFormatter = (() => {
    let _classDecorators_1 = [Injectable()];
    let _classDescriptor_1;
    let _classExtraInitializers_1 = [];
    let _classThis_1;
    var TimeagoCustomFormatter = class extends TimeagoFormatter {
        static {
            __esDecorate(null, _classDescriptor_1 = { value: this }, _classDecorators_1, { kind: "class", name: this.name }, null, _classExtraInitializers_1);
            TimeagoCustomFormatter = _classThis_1 = _classDescriptor_1.value;
            __runInitializers(_classThis_1, _classExtraInitializers_1);
        }
        intl;
        constructor(intl) {
            super();
            this.intl = intl;
        }
        format(then) {
            const { suffix, value, unit } = defaultFormattter(then);
            return this.parse(value, unit, suffix, Date.now(), then);
        }
        parse(value, unit, suffix, now, then) {
            /** convert weeks to days if strings don't handle weeks */
            if (unit === 'week' && !this.intl.strings.week && !this.intl.strings.weeks) {
                const days = Math.round(Math.abs(now - then) / (1000 * 60 * 60 * 24));
                value = days;
                unit = 'day';
            }
            /** create a normalize function for given value */
            const normalize = this.normalizeFn(value, now - then, this.intl.strings.numbers);
            /** The eventual return value stored in an array so that the wordSeparator can be used */
            const dateString = [];
            /** handle prefixes */
            if (suffix === 'ago' && this.intl.strings.prefixAgo) {
                dateString.push(normalize(this.intl.strings.prefixAgo));
            }
            if (suffix === 'from now' && this.intl.strings.prefixFromNow) {
                dateString.push(normalize(this.intl.strings.prefixFromNow));
            }
            /** Handle Main number and unit */
            const isPlural = value > 1;
            if (isPlural) {
                const stringFn = this.intl.strings[unit + 's'] || this.intl.strings[unit] || '%d ' + unit;
                dateString.push(normalize(stringFn));
            }
            else {
                const stringFn = this.intl.strings[unit] || this.intl.strings[unit + 's'] || '%d ' + unit;
                dateString.push(normalize(stringFn));
            }
            /** Handle Suffixes */
            if (suffix === 'ago' && this.intl.strings.suffixAgo) {
                dateString.push(normalize(this.intl.strings.suffixAgo));
            }
            if (suffix === 'from now' && this.intl.strings.suffixFromNow) {
                dateString.push(normalize(this.intl.strings.suffixFromNow));
            }
            /** join the array into a string and return it */
            const wordSeparator = typeof this.intl.strings.wordSeparator === 'string' ? this.intl.strings.wordSeparator : ' ';
            return dateString.join(wordSeparator);
        }
        /**
         * If the numbers array is present, format numbers with it,
         * otherwise just cast the number to a string and return it
        */
        normalizeNumber(numbers, value) {
            return numbers && numbers.length === 10
                ? String(value).split('')
                    .map((digit) => digit.match(/^[0-9]$/) ? numbers[parseInt(digit, 10)] : digit)
                    .join('')
                : String(value);
        }
        /**
         * Take a string or a function that takes number of days and returns a string
         * and provide a uniform API to create string parts
        */
        normalizeFn(value, millisDelta, numbers) {
            return (stringOrFn) => typeof stringOrFn === 'function'
                ? stringOrFn(value, millisDelta).replace(/%d/g, this.normalizeNumber(numbers, value))
                : stringOrFn.replace(/%d/g, this.normalizeNumber(numbers, value));
        }
    };
    return TimeagoCustomFormatter = _classThis_1;
})();
