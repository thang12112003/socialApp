/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, Directive, Input } from '@angular/core';
import { animationFrameScheduler, asapScheduler, merge } from 'rxjs';
import { auditTime } from 'rxjs/operators';
import { getNextSibling, getParent } from './utils';
import * as i0 from "@angular/core";
import * as i1 from "./node-base";
import * as i2 from "./tree";
/**
 * [true, false, false, true] => 1001
 */
function booleanArrayToString(arr) {
    return arr.map(i => (i ? 1 : 0)).join('');
}
const BUILD_INDENTS_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;
export class NzTreeNodeIndentsComponent {
    constructor() {
        this.indents = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NzTreeNodeIndentsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.1", type: NzTreeNodeIndentsComponent, isStandalone: true, selector: "nz-tree-node-indents", inputs: { indents: "indents" }, host: { classAttribute: "ant-tree-indent" }, ngImport: i0, template: `
    @for (isEnd of indents; track isEnd) {
      <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd"></span>
    }
  `, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NzTreeNodeIndentsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-tree-node-indents',
                    template: `
    @for (isEnd of indents; track isEnd) {
      <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd"></span>
    }
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        class: 'ant-tree-indent'
                    },
                    standalone: true
                }]
        }], propDecorators: { indents: [{
                type: Input
            }] } });
export class NzTreeNodeIndentLineDirective {
    constructor(treeNode, tree, cdr) {
        this.treeNode = treeNode;
        this.tree = tree;
        this.cdr = cdr;
        this.isLast = 'unset';
        this.isLeaf = false;
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.currentIndents = '';
        this.buildIndents();
        this.checkLast();
        /**
         * The dependent data (TreeControl.dataNodes) can be set after node instantiation,
         * and setting the indents can cause frame rate loss if it is set too often.
         */
        this.changeSubscription = merge(this.treeNode._dataChanges, tree._dataSourceChanged)
            .pipe(auditTime(0, BUILD_INDENTS_SCHEDULER))
            .subscribe(() => {
            this.buildIndents();
            this.checkAdjacent();
            this.cdr.markForCheck();
        });
    }
    getIndents() {
        const indents = [];
        const nodes = this.tree.treeControl.dataNodes;
        const getLevel = this.tree.treeControl.getLevel;
        let parent = getParent(nodes, this.treeNode.data, getLevel);
        while (parent) {
            const parentNextSibling = getNextSibling(nodes, parent, getLevel);
            if (parentNextSibling) {
                indents.unshift(true);
            }
            else {
                indents.unshift(false);
            }
            parent = getParent(nodes, parent, getLevel);
        }
        return indents;
    }
    buildIndents() {
        if (this.treeNode.data) {
            const indents = this.getIndents();
            const diffString = booleanArrayToString(indents);
            if (diffString !== this.currentIndents) {
                this.treeNode.setIndents(this.getIndents());
                this.currentIndents = diffString;
            }
        }
    }
    /**
     * We need to add an class name for the last child node,
     * this result can also be affected when the adjacent nodes are changed.
     */
    checkAdjacent() {
        const nodes = this.tree.treeControl.dataNodes;
        const index = nodes.indexOf(this.treeNode.data);
        const preNode = nodes[index - 1] || null;
        const nextNode = nodes[index + 1] || null;
        if (this.nextNodeRef !== nextNode || this.preNodeRef !== preNode) {
            this.checkLast(index);
        }
        this.preNodeRef = preNode;
        this.nextNodeRef = nextNode;
    }
    checkLast(index) {
        const nodes = this.tree.treeControl.dataNodes;
        this.isLeaf = this.treeNode.isLeaf;
        this.isLast = !getNextSibling(nodes, this.treeNode.data, this.tree.treeControl.getLevel, index);
    }
    ngOnDestroy() {
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.changeSubscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NzTreeNodeIndentLineDirective, deps: [{ token: i1.NzNodeBase }, { token: i2.NzTreeView }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: NzTreeNodeIndentLineDirective, isStandalone: true, selector: "nz-tree-node[nzTreeNodeIndentLine]", host: { properties: { "class.ant-tree-treenode-leaf-last": "isLast && isLeaf" }, classAttribute: "ant-tree-show-line" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NzTreeNodeIndentLineDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'nz-tree-node[nzTreeNodeIndentLine]',
                    host: {
                        class: 'ant-tree-show-line',
                        '[class.ant-tree-treenode-leaf-last]': 'isLast && isLeaf'
                    },
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.NzNodeBase }, { type: i2.NzTreeView }, { type: i0.ChangeDetectorRef }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy90cmVlLXZpZXcvaW5kZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSx1QkFBdUIsRUFBcUIsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDbkgsT0FBTyxFQUFnQix1QkFBdUIsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ25GLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUkzQyxPQUFPLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQzs7OztBQUVwRDs7R0FFRztBQUNILFNBQVMsb0JBQW9CLENBQUMsR0FBYztJQUMxQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBRUQsTUFBTSx1QkFBdUIsR0FBRyxPQUFPLHFCQUFxQixLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztBQWV2SCxNQUFNLE9BQU8sMEJBQTBCO0lBYnZDO1FBY1csWUFBTyxHQUFjLEVBQUUsQ0FBQztLQUNsQzs4R0FGWSwwQkFBMEI7a0dBQTFCLDBCQUEwQiw2SkFYM0I7Ozs7R0FJVDs7MkZBT1UsMEJBQTBCO2tCQWJ0QyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxzQkFBc0I7b0JBQ2hDLFFBQVEsRUFBRTs7OztHQUlUO29CQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxJQUFJLEVBQUU7d0JBQ0osS0FBSyxFQUFF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QUFrQjtxQkFDMUQ7b0JBQ0QsVUFBVSxFQUFFLElBQUk7aUJBQ2pCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgYXNhcFNjaGVkdWxlciwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGF1ZGl0VGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnpOb2RlQmFzZSB9IGZyb20gJy4vbm9kZS1iYXNlJztcbmltcG9ydCB7IE56VHJlZVZpZXcgfSBmcm9tICcuL3RyZWUnO1xuaW1wb3J0IHsgZ2V0TmV4dFNpYmxpbmcsIGdldFBhcmVudCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFt0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWVdID0+IDEwMDFcbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkFycmF5VG9TdHJpbmcoYXJyOiBib29sZWFuW10pOiBzdHJpbmcge1xuICByZXR1cm4gYXJyLm1hcChpID0+IChpID8gMSA6IDApKS5qb2luKCcnKTtcbn1cblxuY29uc3QgQlVJTERfSU5ERU5UU19TQ0hFRFVMRVIgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJyA/IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyIDogYXNhcFNjaGVkdWxlcjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbnotdHJlZS1ub2RlLWluZGVudHMnLFxuICB0ZW1wbGF0ZTogYFxuICAgIEBmb3IgKGlzRW5kIG9mIGluZGVudHM7IHRyYWNrIGlzRW5kKSB7XG4gICAgICA8c3BhbiBjbGFzcz1cImFudC10cmVlLWluZGVudC11bml0XCIgW2NsYXNzLmFudC10cmVlLWluZGVudC11bml0LWVuZF09XCIhaXNFbmRcIj48L3NwYW4+XG4gICAgfVxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnYW50LXRyZWUtaW5kZW50J1xuICB9LFxuICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIE56VHJlZU5vZGVJbmRlbnRzQ29tcG9uZW50IHtcbiAgQElucHV0KCkgaW5kZW50czogYm9vbGVhbltdID0gW107XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ256LXRyZWUtbm9kZVtuelRyZWVOb2RlSW5kZW50TGluZV0nLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICdhbnQtdHJlZS1zaG93LWxpbmUnLFxuICAgICdbY2xhc3MuYW50LXRyZWUtdHJlZW5vZGUtbGVhZi1sYXN0XSc6ICdpc0xhc3QgJiYgaXNMZWFmJ1xuICB9LFxuICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIE56VHJlZU5vZGVJbmRlbnRMaW5lRGlyZWN0aXZlPFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgaXNMYXN0OiBib29sZWFuIHwgJ3Vuc2V0JyA9ICd1bnNldCc7XG4gIGlzTGVhZiA9IGZhbHNlO1xuICBwcml2YXRlIHByZU5vZGVSZWY6IFQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBuZXh0Tm9kZVJlZjogVCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGN1cnJlbnRJbmRlbnRzOiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBjaGFuZ2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRyZWVOb2RlOiBOek5vZGVCYXNlPFQ+LFxuICAgIHByaXZhdGUgdHJlZTogTnpUcmVlVmlldzxUPixcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7XG4gICAgdGhpcy5idWlsZEluZGVudHMoKTtcbiAgICB0aGlzLmNoZWNrTGFzdCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlcGVuZGVudCBkYXRhIChUcmVlQ29udHJvbC5kYXRhTm9kZXMpIGNhbiBiZSBzZXQgYWZ0ZXIgbm9kZSBpbnN0YW50aWF0aW9uLFxuICAgICAqIGFuZCBzZXR0aW5nIHRoZSBpbmRlbnRzIGNhbiBjYXVzZSBmcmFtZSByYXRlIGxvc3MgaWYgaXQgaXMgc2V0IHRvbyBvZnRlbi5cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbiA9IG1lcmdlKHRoaXMudHJlZU5vZGUuX2RhdGFDaGFuZ2VzLCB0cmVlLl9kYXRhU291cmNlQ2hhbmdlZClcbiAgICAgIC5waXBlKGF1ZGl0VGltZSgwLCBCVUlMRF9JTkRFTlRTX1NDSEVEVUxFUikpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5idWlsZEluZGVudHMoKTtcbiAgICAgICAgdGhpcy5jaGVja0FkamFjZW50KCk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldEluZGVudHMoKTogYm9vbGVhbltdIHtcbiAgICBjb25zdCBpbmRlbnRzID0gW107XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLnRyZWUudHJlZUNvbnRyb2wuZGF0YU5vZGVzO1xuICAgIGNvbnN0IGdldExldmVsID0gdGhpcy50cmVlLnRyZWVDb250cm9sLmdldExldmVsO1xuICAgIGxldCBwYXJlbnQgPSBnZXRQYXJlbnQobm9kZXMsIHRoaXMudHJlZU5vZGUuZGF0YSwgZ2V0TGV2ZWwpO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGNvbnN0IHBhcmVudE5leHRTaWJsaW5nID0gZ2V0TmV4dFNpYmxpbmcobm9kZXMsIHBhcmVudCwgZ2V0TGV2ZWwpO1xuICAgICAgaWYgKHBhcmVudE5leHRTaWJsaW5nKSB7XG4gICAgICAgIGluZGVudHMudW5zaGlmdCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudHMudW5zaGlmdChmYWxzZSk7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBnZXRQYXJlbnQobm9kZXMsIHBhcmVudCwgZ2V0TGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZW50cztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRJbmRlbnRzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyZWVOb2RlLmRhdGEpIHtcbiAgICAgIGNvbnN0IGluZGVudHMgPSB0aGlzLmdldEluZGVudHMoKTtcbiAgICAgIGNvbnN0IGRpZmZTdHJpbmcgPSBib29sZWFuQXJyYXlUb1N0cmluZyhpbmRlbnRzKTtcbiAgICAgIGlmIChkaWZmU3RyaW5nICE9PSB0aGlzLmN1cnJlbnRJbmRlbnRzKSB7XG4gICAgICAgIHRoaXMudHJlZU5vZGUuc2V0SW5kZW50cyh0aGlzLmdldEluZGVudHMoKSk7XG4gICAgICAgIHRoaXMuY3VycmVudEluZGVudHMgPSBkaWZmU3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBuZWVkIHRvIGFkZCBhbiBjbGFzcyBuYW1lIGZvciB0aGUgbGFzdCBjaGlsZCBub2RlLFxuICAgKiB0aGlzIHJlc3VsdCBjYW4gYWxzbyBiZSBhZmZlY3RlZCB3aGVuIHRoZSBhZGphY2VudCBub2RlcyBhcmUgY2hhbmdlZC5cbiAgICovXG4gIHByaXZhdGUgY2hlY2tBZGphY2VudCgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMudHJlZS50cmVlQ29udHJvbC5kYXRhTm9kZXM7XG4gICAgY29uc3QgaW5kZXggPSBub2Rlcy5pbmRleE9mKHRoaXMudHJlZU5vZGUuZGF0YSk7XG4gICAgY29uc3QgcHJlTm9kZSA9IG5vZGVzW2luZGV4IC0gMV0gfHwgbnVsbDtcbiAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2luZGV4ICsgMV0gfHwgbnVsbDtcbiAgICBpZiAodGhpcy5uZXh0Tm9kZVJlZiAhPT0gbmV4dE5vZGUgfHwgdGhpcy5wcmVOb2RlUmVmICE9PSBwcmVOb2RlKSB7XG4gICAgICB0aGlzLmNoZWNrTGFzdChpbmRleCk7XG4gICAgfVxuICAgIHRoaXMucHJlTm9kZVJlZiA9IHByZU5vZGU7XG4gICAgdGhpcy5uZXh0Tm9kZVJlZiA9IG5leHROb2RlO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0xhc3QoaW5kZXg/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMudHJlZS50cmVlQ29udHJvbC5kYXRhTm9kZXM7XG4gICAgdGhpcy5pc0xlYWYgPSB0aGlzLnRyZWVOb2RlLmlzTGVhZjtcbiAgICB0aGlzLmlzTGFzdCA9ICFnZXROZXh0U2libGluZyhub2RlcywgdGhpcy50cmVlTm9kZS5kYXRhLCB0aGlzLnRyZWUudHJlZUNvbnRyb2wuZ2V0TGV2ZWwsIGluZGV4KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMucHJlTm9kZVJlZiA9IG51bGw7XG4gICAgdGhpcy5uZXh0Tm9kZVJlZiA9IG51bGw7XG4gICAgdGhpcy5jaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19