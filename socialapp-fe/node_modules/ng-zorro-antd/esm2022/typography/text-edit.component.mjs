/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { ChangeDetectionStrategy, Component, EventEmitter, Injector, Input, Output, ViewChild, ViewEncapsulation, afterNextRender, inject } from '@angular/core';
import { BehaviorSubject, EMPTY, Observable, fromEvent } from 'rxjs';
import { first, switchMap, takeUntil } from 'rxjs/operators';
import { NzOutletModule } from 'ng-zorro-antd/core/outlet';
import { NzDestroyService } from 'ng-zorro-antd/core/services';
import { NzTransButtonModule } from 'ng-zorro-antd/core/trans-button';
import { NzIconModule } from 'ng-zorro-antd/icon';
import { NzAutosizeDirective, NzInputModule } from 'ng-zorro-antd/input';
import { NzToolTipModule } from 'ng-zorro-antd/tooltip';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/i18n";
import * as i2 from "ng-zorro-antd/core/services";
import * as i3 from "ng-zorro-antd/input";
import * as i4 from "ng-zorro-antd/core/trans-button";
import * as i5 from "ng-zorro-antd/icon";
import * as i6 from "ng-zorro-antd/tooltip";
import * as i7 from "ng-zorro-antd/core/outlet";
export class NzTextEditComponent {
    set textarea(textarea) {
        this.textarea$.next(textarea);
    }
    constructor(ngZone, host, cdr, i18n, destroy$) {
        this.ngZone = ngZone;
        this.host = host;
        this.cdr = cdr;
        this.i18n = i18n;
        this.destroy$ = destroy$;
        this.editing = false;
        this.icon = 'edit';
        this.startEditing = new EventEmitter();
        this.endEditing = new EventEmitter(true);
        this.nativeElement = this.host.nativeElement;
        // We could've saved the textarea within some private property (e.g. `_textarea`) and have a getter,
        // but having subject makes the code more reactive and cancellable (e.g. event listeners will be
        // automatically removed and re-added through the `switchMap` below).
        this.textarea$ = new BehaviorSubject(null);
        this.injector = inject(Injector);
    }
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.locale = this.i18n.getLocaleData('Text');
            this.cdr.markForCheck();
        });
        this.textarea$
            .pipe(switchMap(textarea => 
        // Caretaker note: we explicitly should call `subscribe()` within the root zone.
        // `runOutsideAngular(() => fromEvent(...))` will just create an observable within the root zone,
        // but `addEventListener` is called when the `fromEvent` is subscribed.
        textarea
            ? new Observable(subscriber => this.ngZone.runOutsideAngular(() => fromEvent(textarea.nativeElement, 'keydown').subscribe(subscriber)))
            : EMPTY), takeUntil(this.destroy$))
            .subscribe(event => {
            // Caretaker note: adding modifier at the end (for instance `(keydown.esc)`) will tell Angular to add
            // an event listener through the `KeyEventsPlugin`, which always runs `ngZone.runGuarded()` internally.
            // We're interested only in escape and enter keyboard buttons, otherwise Angular will run change detection
            // on any `keydown` event.
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                return;
            }
            this.ngZone.run(() => {
                if (event.keyCode === ESCAPE) {
                    this.onCancel();
                }
                else {
                    this.onEnter(event);
                }
                this.cdr.markForCheck();
            });
        });
        this.textarea$
            .pipe(switchMap(textarea => textarea
            ? new Observable(subscriber => this.ngZone.runOutsideAngular(() => fromEvent(textarea.nativeElement, 'input').subscribe(subscriber)))
            : EMPTY), takeUntil(this.destroy$))
            .subscribe(event => {
            this.currentText = event.target.value;
        });
    }
    onClick() {
        this.beforeText = this.text;
        this.currentText = this.beforeText;
        this.editing = true;
        this.startEditing.emit();
        this.focusAndSetValue();
    }
    confirm() {
        this.editing = false;
        this.endEditing.emit(this.currentText);
    }
    onEnter(event) {
        event.stopPropagation();
        event.preventDefault();
        this.confirm();
    }
    onCancel() {
        this.currentText = this.beforeText;
        this.confirm();
    }
    focusAndSetValue() {
        const { injector } = this;
        afterNextRender(() => {
            this.textarea$
                .pipe(
            // It may still not be available, so we need to wait until view queries
            // are executed during the change detection. It's safer to wait until
            // the query runs and the textarea is set on the behavior subject.
            first((textarea) => textarea != null), takeUntil(this.destroy$))
                .subscribe(textarea => {
                textarea.nativeElement.focus();
                textarea.nativeElement.value = this.currentText || '';
                this.autosizeDirective.resizeToFitContent();
                this.cdr.markForCheck();
            });
        }, { injector });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NzTextEditComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i1.NzI18nService }, { token: i2.NzDestroyService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.1", type: NzTextEditComponent, isStandalone: true, selector: "nz-text-edit", inputs: { text: "text", icon: "icon", tooltip: "tooltip" }, outputs: { startEditing: "startEditing", endEditing: "endEditing" }, providers: [NzDestroyService], viewQueries: [{ propertyName: "textarea", first: true, predicate: ["textarea"], descendants: true }, { propertyName: "autosizeDirective", first: true, predicate: NzAutosizeDirective, descendants: true }], exportAs: ["nzTextEdit"], ngImport: i0, template: `
    @if (editing) {
      <textarea #textarea nz-input nzAutosize (blur)="confirm()"></textarea>
      <button nz-trans-button class="ant-typography-edit-content-confirm" (click)="confirm()">
        <span nz-icon nzType="enter"></span>
      </button>
    } @else {
      <button
        nz-tooltip
        nz-trans-button
        class="ant-typography-edit"
        [nzTooltipTitle]="tooltip === null ? null : tooltip || locale?.edit"
        (click)="onClick()"
      >
        <ng-container *nzStringTemplateOutlet="icon; let icon">
          <span nz-icon [nzType]="icon"></span>
        </ng-container>
      </button>
    }
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: NzInputModule }, { kind: "directive", type: i3.NzInputDirective, selector: "input[nz-input],textarea[nz-input]", inputs: ["nzBorderless", "nzSize", "nzStepperless", "nzStatus", "disabled"], exportAs: ["nzInput"] }, { kind: "directive", type: i3.NzAutosizeDirective, selector: "textarea[nzAutosize]", inputs: ["nzAutosize"], exportAs: ["nzAutosize"] }, { kind: "ngmodule", type: NzTransButtonModule }, { kind: "directive", type: i4.NzTransButtonDirective, selector: "button[nz-trans-button]" }, { kind: "ngmodule", type: NzIconModule }, { kind: "directive", type: i5.NzIconDirective, selector: "[nz-icon]", inputs: ["nzSpin", "nzRotate", "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], exportAs: ["nzIcon"] }, { kind: "ngmodule", type: NzToolTipModule }, { kind: "directive", type: i6.NzTooltipDirective, selector: "[nz-tooltip]", inputs: ["nzTooltipTitle", "nzTooltipTitleContext", "nz-tooltip", "nzTooltipTrigger", "nzTooltipPlacement", "nzTooltipOrigin", "nzTooltipVisible", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipArrowPointAtCenter", "cdkConnectedOverlayPush", "nzTooltipColor"], outputs: ["nzTooltipVisibleChange"], exportAs: ["nzTooltip"] }, { kind: "ngmodule", type: NzOutletModule }, { kind: "directive", type: i7.NzStringTemplateOutletDirective, selector: "[nzStringTemplateOutlet]", inputs: ["nzStringTemplateOutletContext", "nzStringTemplateOutlet"], exportAs: ["nzStringTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NzTextEditComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nz-text-edit',
                    exportAs: 'nzTextEdit',
                    template: `
    @if (editing) {
      <textarea #textarea nz-input nzAutosize (blur)="confirm()"></textarea>
      <button nz-trans-button class="ant-typography-edit-content-confirm" (click)="confirm()">
        <span nz-icon nzType="enter"></span>
      </button>
    } @else {
      <button
        nz-tooltip
        nz-trans-button
        class="ant-typography-edit"
        [nzTooltipTitle]="tooltip === null ? null : tooltip || locale?.edit"
        (click)="onClick()"
      >
        <ng-container *nzStringTemplateOutlet="icon; let icon">
          <span nz-icon [nzType]="icon"></span>
        </ng-container>
      </button>
    }
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    preserveWhitespaces: false,
                    providers: [NzDestroyService],
                    imports: [NzInputModule, NzTransButtonModule, NzIconModule, NzToolTipModule, NzOutletModule],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.NzI18nService }, { type: i2.NzDestroyService }], propDecorators: { text: [{
                type: Input
            }], icon: [{
                type: Input
            }], tooltip: [{
                type: Input
            }], startEditing: [{
                type: Output
            }], endEditing: [{
                type: Output
            }], textarea: [{
                type: ViewChild,
                args: ['textarea', { static: false }]
            }], autosizeDirective: [{
                type: ViewChild,
                args: [NzAutosizeDirective, { static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC1lZGl0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2NvbXBvbmVudHMvdHlwb2dyYXBoeS90ZXh0LWVkaXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEQsT0FBTyxFQUNMLHVCQUF1QixFQUV2QixTQUFTLEVBRVQsWUFBWSxFQUNaLFFBQVEsRUFDUixLQUFLLEVBR0wsTUFBTSxFQUNOLFNBQVMsRUFDVCxpQkFBaUIsRUFDakIsZUFBZSxFQUNmLE1BQU0sRUFDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsZUFBZSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUd0RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDbEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLGFBQWEsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7Ozs7Ozs7O0FBZ0N4RCxNQUFNLE9BQU8sbUJBQW1CO0lBUzlCLElBQ0ksUUFBUSxDQUFDLFFBQXFEO1FBQ2hFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFjRCxZQUNVLE1BQWMsRUFD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QjsrTEFLVSxJQUFJO3NCQUFaLEtBQUs7Z0JBQ0csSUFBSTtzQkFBWixLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFDYSxZQUFZO3NCQUE5QixNQUFNO2dCQUNZLFVBQVU7c0JBQTVCLE1BQU07Z0JBRUgsUUFBUTtzQkFEWCxTQUFTO3VCQUFDLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Z0JBSVcsaUJBQWlCO3NCQUFuRSxTQUFTO3VCQUFDLG1CQUFtQixFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IEVOVEVSLCBFU0NBUEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBhZnRlck5leHRSZW5kZXIsXG4gIGluamVjdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgRU1QVFksIE9ic2VydmFibGUsIGZyb21FdmVudCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlyc3QsIHN3aXRjaE1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOek91dGxldE1vZHVsZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS9vdXRsZXQnO1xuaW1wb3J0IHsgTnpEZXN0cm95U2VydmljZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBOelRyYW5zQnV0dG9uTW9kdWxlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3RyYW5zLWJ1dHRvbic7XG5pbXBvcnQgeyBOelRTVHlwZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS90eXBlcyc7XG5pbXBvcnQgeyBOekkxOG5TZXJ2aWNlLCBOelRleHRJMThuSW50ZXJmYWNlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9pMThuJztcbmltcG9ydCB7IE56SWNvbk1vZHVsZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvaWNvbic7XG5pbXBvcnQgeyBOekF1dG9zaXplRGlyZWN0aXZlLCBOeklucHV0TW9kdWxlIH0gZnJvbSAnbmctem9ycm8tYW50ZC9pbnB1dCc7XG5pbXBvcnQgeyBOelRvb2xUaXBNb2R1bGUgfSBmcm9tICduZy16b3Jyby1hbnRkL3Rvb2x0aXAnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduei10ZXh0LWVkaXQnLFxuICBleHBvcnRBczogJ256VGV4dEVkaXQnLFxuICB0ZW1wbGF0ZTogYFxuICAgIEBpZiAoZWRpdGluZykge1xuICAgICAgPHRleHRhcmVhICN0ZXh0YXJlYSBuei1pbnB1dCBuekF1dG9zaXplIChibHVyKT1cImNvbmZpcm0oKVwiPjwvdGV4dGFyZWE+XG4gICAgICA8YnV0dG9uIG56LXRyYW5zLWJ1dHRvbiBjbGFzcz1cImFudC10eXBvZ3JhcGh5LWVkaXQtY29udGVudC1jb25maXJtXCIgKGNsaWNrKT1cImNvbmZpcm0oKVwiPlxuICAgICAgICA8c3BhbiBuei1pY29uIG56VHlwZT1cImVudGVyXCI+PC9zcGFuPlxuICAgICAgPC9idXR0b24+XG4gICAgfSBAZWxzZSB7XG4gICAgICA8YnV0dG9uXG4gICAgICAgIG56LXRvb2x0aXBcbiAgICAgICAgbnotdHJhbnMtYnV0dG9uXG4gICAgICAgIGNsYXNzPVwiYW50LXR5cG9ncmFwaHktZWRpdFwiXG4gICAgICAgIFtuelRvb2x0aXBUaXRsZV09XCJ0b29sdGlwID09PSBudWxsID8gbnVsbCA6IHRvb2x0aXAgfHwgbG9jYWxlPy5lZGl0XCJcbiAgICAgICAgKGNsaWNrKT1cIm9uQ2xpY2soKVwiXG4gICAgICA+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm56U3RyaW5nVGVtcGxhdGVPdXRsZXQ9XCJpY29uOyBsZXQgaWNvblwiPlxuICAgICAgICAgIDxzcGFuIG56LWljb24gW256VHlwZV09XCJpY29uXCI+PC9zcGFuPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvYnV0dG9uPlxuICAgIH1cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBwcm92aWRlcnM6IFtOekRlc3Ryb3lTZXJ2aWNlXSxcbiAgaW1wb3J0czogW056SW5wdXRNb2R1bGUsIE56VHJhbnNCdXR0b25Nb2R1bGUsIE56SWNvbk1vZHVsZSwgTnpUb29sVGlwTW9kdWxlLCBOek91dGxldE1vZHVsZV0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgTnpUZXh0RWRpdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGVkaXRpbmcgPSBmYWxzZTtcbiAgbG9jYWxlITogTnpUZXh0STE4bkludGVyZmFjZTtcblxuICBASW5wdXQoKSB0ZXh0Pzogc3RyaW5nO1xuICBASW5wdXQoKSBpY29uOiBOelRTVHlwZSA9ICdlZGl0JztcbiAgQElucHV0KCkgdG9vbHRpcD86IG51bGwgfCBOelRTVHlwZTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHN0YXJ0RWRpdGluZyA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IGVuZEVkaXRpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4odHJ1ZSk7XG4gIEBWaWV3Q2hpbGQoJ3RleHRhcmVhJywgeyBzdGF0aWM6IGZhbHNlIH0pXG4gIHNldCB0ZXh0YXJlYSh0ZXh0YXJlYTogRWxlbWVudFJlZjxIVE1MVGV4dEFyZWFFbGVtZW50PiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudGV4dGFyZWEkLm5leHQodGV4dGFyZWEpO1xuICB9XG4gIEBWaWV3Q2hpbGQoTnpBdXRvc2l6ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pIGF1dG9zaXplRGlyZWN0aXZlITogTnpBdXRvc2l6ZURpcmVjdGl2ZTtcblxuICBiZWZvcmVUZXh0Pzogc3RyaW5nO1xuICBjdXJyZW50VGV4dD86IHN0cmluZztcbiAgbmF0aXZlRWxlbWVudCA9IHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50O1xuXG4gIC8vIFdlIGNvdWxkJ3ZlIHNhdmVkIHRoZSB0ZXh0YXJlYSB3aXRoaW4gc29tZSBwcml2YXRlIHByb3BlcnR5IChlLmcuIGBfdGV4dGFyZWFgKSBhbmQgaGF2ZSBhIGdldHRlcixcbiAgLy8gYnV0IGhhdmluZyBzdWJqZWN0IG1ha2VzIHRoZSBjb2RlIG1vcmUgcmVhY3RpdmUgYW5kIGNhbmNlbGxhYmxlIChlLmcuIGV2ZW50IGxpc3RlbmVycyB3aWxsIGJlXG4gIC8vIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhbmQgcmUtYWRkZWQgdGhyb3VnaCB0aGUgYHN3aXRjaE1hcGAgYmVsb3cpLlxuICBwcml2YXRlIHRleHRhcmVhJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RWxlbWVudFJlZjxIVE1MVGV4dEFyZWFFbGVtZW50PiB8IG51bGwgfCB1bmRlZmluZWQ+KG51bGwpO1xuXG4gIHByaXZhdGUgaW5qZWN0b3IgPSBpbmplY3QoSW5qZWN0b3IpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG4gICAgcHJpdmF0ZSBob3N0OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBpMThuOiBOekkxOG5TZXJ2aWNlLFxuICAgIHByaXZhdGUgZGVzdHJveSQ6IE56RGVzdHJveVNlcnZpY2VcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaTE4bi5sb2NhbGVDaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmxvY2FsZSA9IHRoaXMuaTE4bi5nZXRMb2NhbGVEYXRhKCdUZXh0Jyk7XG4gICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9KTtcblxuICAgIHRoaXMudGV4dGFyZWEkXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKHRleHRhcmVhID0+XG4gICAgICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGV4cGxpY2l0bHkgc2hvdWxkIGNhbGwgYHN1YnNjcmliZSgpYCB3aXRoaW4gdGhlIHJvb3Qgem9uZS5cbiAgICAgICAgICAvLyBgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gZnJvbUV2ZW50KC4uLikpYCB3aWxsIGp1c3QgY3JlYXRlIGFuIG9ic2VydmFibGUgd2l0aGluIHRoZSByb290IHpvbmUsXG4gICAgICAgICAgLy8gYnV0IGBhZGRFdmVudExpc3RlbmVyYCBpcyBjYWxsZWQgd2hlbiB0aGUgYGZyb21FdmVudGAgaXMgc3Vic2NyaWJlZC5cbiAgICAgICAgICB0ZXh0YXJlYVxuICAgICAgICAgICAgPyBuZXcgT2JzZXJ2YWJsZTxLZXlib2FyZEV2ZW50PihzdWJzY3JpYmVyID0+XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgICAgICAgIGZyb21FdmVudDxLZXlib2FyZEV2ZW50Pih0ZXh0YXJlYS5uYXRpdmVFbGVtZW50LCAna2V5ZG93bicpLnN1YnNjcmliZShzdWJzY3JpYmVyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBFTVBUWVxuICAgICAgICApLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAvLyBDYXJldGFrZXIgbm90ZTogYWRkaW5nIG1vZGlmaWVyIGF0IHRoZSBlbmQgKGZvciBpbnN0YW5jZSBgKGtleWRvd24uZXNjKWApIHdpbGwgdGVsbCBBbmd1bGFyIHRvIGFkZFxuICAgICAgICAvLyBhbiBldmVudCBsaXN0ZW5lciB0aHJvdWdoIHRoZSBgS2V5RXZlbnRzUGx1Z2luYCwgd2hpY2ggYWx3YXlzIHJ1bnMgYG5nWm9uZS5ydW5HdWFyZGVkKClgIGludGVybmFsbHkuXG4gICAgICAgIC8vIFdlJ3JlIGludGVyZXN0ZWQgb25seSBpbiBlc2NhcGUgYW5kIGVudGVyIGtleWJvYXJkIGJ1dHRvbnMsIG90aGVyd2lzZSBBbmd1bGFyIHdpbGwgcnVuIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgICAgLy8gb24gYW55IGBrZXlkb3duYCBldmVudC5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IEVTQ0FQRSAmJiBldmVudC5rZXlDb2RlICE9PSBFTlRFUikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSkge1xuICAgICAgICAgICAgdGhpcy5vbkNhbmNlbCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRW50ZXIoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHRoaXMudGV4dGFyZWEkXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKHRleHRhcmVhID0+XG4gICAgICAgICAgdGV4dGFyZWFcbiAgICAgICAgICAgID8gbmV3IE9ic2VydmFibGU8S2V5Ym9hcmRFdmVudD4oc3Vic2NyaWJlciA9PlxuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgICBmcm9tRXZlbnQ8S2V5Ym9hcmRFdmVudD4odGV4dGFyZWEubmF0aXZlRWxlbWVudCwgJ2lucHV0Jykuc3Vic2NyaWJlKHN1YnNjcmliZXIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IEVNUFRZXG4gICAgICAgICksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudFRleHQgPSAoZXZlbnQudGFyZ2V0IGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQpLnZhbHVlO1xuICAgICAgfSk7XG4gIH1cblxuICBvbkNsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuYmVmb3JlVGV4dCA9IHRoaXMudGV4dDtcbiAgICB0aGlzLmN1cnJlbnRUZXh0ID0gdGhpcy5iZWZvcmVUZXh0O1xuICAgIHRoaXMuZWRpdGluZyA9IHRydWU7XG4gICAgdGhpcy5zdGFydEVkaXRpbmcuZW1pdCgpO1xuICAgIHRoaXMuZm9jdXNBbmRTZXRWYWx1ZSgpO1xuICB9XG5cbiAgY29uZmlybSgpOiB2b2lkIHtcbiAgICB0aGlzLmVkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuZEVkaXRpbmcuZW1pdCh0aGlzLmN1cnJlbnRUZXh0KTtcbiAgfVxuXG4gIG9uRW50ZXIoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmNvbmZpcm0oKTtcbiAgfVxuXG4gIG9uQ2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRleHQgPSB0aGlzLmJlZm9yZVRleHQ7XG4gICAgdGhpcy5jb25maXJtKCk7XG4gIH1cblxuICBmb2N1c0FuZFNldFZhbHVlKCk6IHZvaWQge1xuICAgIGNvbnN0IHsgaW5qZWN0b3IgfSA9IHRoaXM7XG5cbiAgICBhZnRlck5leHRSZW5kZXIoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMudGV4dGFyZWEkXG4gICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAvLyBJdCBtYXkgc3RpbGwgbm90IGJlIGF2YWlsYWJsZSwgc28gd2UgbmVlZCB0byB3YWl0IHVudGlsIHZpZXcgcXVlcmllc1xuICAgICAgICAgICAgLy8gYXJlIGV4ZWN1dGVkIGR1cmluZyB0aGUgY2hhbmdlIGRldGVjdGlvbi4gSXQncyBzYWZlciB0byB3YWl0IHVudGlsXG4gICAgICAgICAgICAvLyB0aGUgcXVlcnkgcnVucyBhbmQgdGhlIHRleHRhcmVhIGlzIHNldCBvbiB0aGUgYmVoYXZpb3Igc3ViamVjdC5cbiAgICAgICAgICAgIGZpcnN0KCh0ZXh0YXJlYSk6IHRleHRhcmVhIGlzIEVsZW1lbnRSZWY8SFRNTFRleHRBcmVhRWxlbWVudD4gPT4gdGV4dGFyZWEgIT0gbnVsbCksXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICAgICAgICApXG4gICAgICAgICAgLnN1YnNjcmliZSh0ZXh0YXJlYSA9PiB7XG4gICAgICAgICAgICB0ZXh0YXJlYS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB0ZXh0YXJlYS5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5jdXJyZW50VGV4dCB8fCAnJztcbiAgICAgICAgICAgIHRoaXMuYXV0b3NpemVEaXJlY3RpdmUucmVzaXplVG9GaXRDb250ZW50KCk7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7IGluamVjdG9yIH1cbiAgICApO1xuICB9XG59XG4iXX0=